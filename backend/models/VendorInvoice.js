import mongoose from 'mongoose';

const vendorInvoiceSchema = new mongoose.Schema({
  // Invoice Details
  invoiceNumber: {
    type: String,
    unique: true
    // Auto-generated by pre-save hook
  },
  saleNumber: {
    type: Number
    // Auto-generated by pre-save hook
  },
  invoiceDate: {
    type: Date,
    default: Date.now
  },

  // Auction Reference
  auction: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Auction',
    required: true
  },

  // Vendor Details
  vendor: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Vendor',
    required: true
  },
  vendorDetails: {
    vendorCode: String,
    name: { type: String, required: true },
    email: String,
    mobile: String,
    address: String,
    commissionPercentage: { type: Number, required: true }
  },

  // Bank Details (for payment)
  bankDetails: {
    accountHolderName: String,
    accountNumber: String,
    ifscCode: String,
    bankName: String,
    branchName: String
  },

  // Lot Details (Array for multiple lots)
  lots: [{
    lotNumber: { type: Number, required: true },
    description: { type: String, required: true },
    hammerPrice: { type: Number, required: true },
    commissionRate: { type: Number, required: true }, // Percentage
    commissionAmount: { type: Number, required: true }, // Calculated
    netPayable: { type: Number, required: true }, // Hammer price - commission
    soldDuringAuction: { type: Boolean, default: true }, // false if sold later as unsold lot
    soldDate: { type: Date, default: Date.now },
    customerInvoice: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'AuctionInvoice',
      default: null
    }
  }],

  // Amount Summary
  amounts: {
    totalHammerPrice: { type: Number, default: 0 },
    totalCommission: { type: Number, default: 0 },
    totalNetPayable: { type: Number, default: 0 },
    roundOff: { type: Number, default: 0 },
    finalPayable: { type: Number, default: 0 }
  },

  // Payment Status
  isPaid: {
    type: Boolean,
    default: false
  },
  paidAt: Date,
  paymentMode: String,
  paymentReference: String,

  // Company Details (Chronicle Vaults)
  companyDetails: {
    name: { type: String, default: 'Chronicle Vaults' },
    gstin: String,
    pan: String,
    address: String,
    city: String,
    state: String,
    phone: String,
    email: String
  },

  // Status
  status: {
    type: String,
    enum: ['Draft', 'Generated', 'Sent', 'Paid', 'Cancelled'],
    default: 'Draft'
  },

  // Notes
  notes: String,
  termsAndConditions: String

}, {
  timestamps: true
});

// Auto-generate invoice number
vendorInvoiceSchema.pre('save', async function(next) {
  if (!this.invoiceNumber) {
    const count = await mongoose.model('VendorInvoice').countDocuments();
    const saleNum = this.saleNumber || (count + 1);
    this.saleNumber = saleNum;
    this.invoiceNumber = `V/SALE${saleNum}/${Math.floor(Math.random() * 1000)}`;
  }
  next();
});

// Calculate commission and amounts before saving
vendorInvoiceSchema.pre('save', function(next) {
  // Calculate commission and net payable for each lot
  this.lots.forEach(lot => {
    lot.commissionAmount = (lot.hammerPrice * lot.commissionRate) / 100;
    lot.netPayable = lot.hammerPrice - lot.commissionAmount;
  });

  // Calculate totals
  this.amounts.totalHammerPrice = this.lots.reduce((sum, lot) => sum + (lot.hammerPrice || 0), 0);
  this.amounts.totalCommission = this.lots.reduce((sum, lot) => sum + (lot.commissionAmount || 0), 0);
  this.amounts.totalNetPayable = this.lots.reduce((sum, lot) => sum + (lot.netPayable || 0), 0);

  // Round off
  const subtotal = this.amounts.totalNetPayable;
  this.amounts.roundOff = Math.round(subtotal) - subtotal;
  this.amounts.finalPayable = Math.round(subtotal);

  next();
});

// Index for faster queries
vendorInvoiceSchema.index({ invoiceNumber: 1 });
vendorInvoiceSchema.index({ vendor: 1 });
vendorInvoiceSchema.index({ auction: 1 });
vendorInvoiceSchema.index({ auction: 1, vendor: 1 });
vendorInvoiceSchema.index({ status: 1 });

export default mongoose.model('VendorInvoice', vendorInvoiceSchema);
